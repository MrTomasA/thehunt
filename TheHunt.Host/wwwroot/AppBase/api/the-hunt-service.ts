/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.3.5.0 (NJsonSchema v9.4.5.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

namespace TheHunt.Client {

export interface ITheHuntClient {
    saveBusinessStream(businessStream: BusinessStream): ng.IPromise<BusinessStream | null>;
}

export class TheHuntClient implements ITheHuntClient {
    private baseUrl: string | undefined = undefined; 
    private http: ng.IHttpService; 
    private q: ng.IQService; 
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:63585";
    }

    saveBusinessStream(businessStream: BusinessStream): ng.IPromise<BusinessStream | null> {
        let url_ = this.baseUrl + "/api/Company/business-stream";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessStream);

        var options_ = <ng.IRequestConfig>{
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [], 
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSaveBusinessStream(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSaveBusinessStream(_response);
            throw _response;
        });
    }

    protected processSaveBusinessStream(response: any): ng.IPromise<BusinessStream | null> {
        const status = response.status; 

        if (status === 201) {
            const _responseText = response.data;
            let result201: BusinessStream | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? BusinessStream.fromJS(resultData201) : <any>null;
            return this.q.resolve(result201);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText);
        }
        return this.q.resolve<BusinessStream | null>(<any>null);
    }
}

export class BusinessStream implements IBusinessStream {
    id?: number | null;
    businessStreamName?: string | null;

    constructor(data?: IBusinessStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.businessStreamName = data["businessStreamName"] !== undefined ? data["businessStreamName"] : <any>null;
        }
    }

    static fromJS(data: any): BusinessStream {
        let result = new BusinessStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["businessStreamName"] = this.businessStreamName !== undefined ? this.businessStreamName : <any>null;
        return data; 
    }
}

export interface IBusinessStream {
    id?: number | null;
    businessStreamName?: string | null;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(q: ng.IQService, message: string, status: number, response: string, result?: any): ng.IPromise<any> {
    if(result !== null && result !== undefined)
        return q.reject(result);
    else
        return q.reject(new SwaggerException(message, status, response, null));
}

function blobToText(blob: Blob, q: ng.IQService): ng.IPromise<string> {
    return new q((resolve) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            resolve(this.result);
        }
        reader.readAsText(blob); 
    });
}

// build angular registrations for the client(s)
let clientClasses = {'TheHuntClient': TheHuntClient};

for (let clientClass in clientClasses) {
    if (clientClasses.hasOwnProperty(clientClass)) {
        angular.module('angularApp').service(clientClass, ['$http', '$q', clientClasses[clientClass]]);
    }
}
}